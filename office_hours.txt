I want to determine for each function in a crate if itself or any method it calls has an unsafe block in it. 

My current approach is to propagate the information based on the local calls, and save it in a file. 

For an external call, I lookup by function name in the analysis output for the crate and function and use the value already calculated. 

First, I have a visitor that collects all the calls for each function:
impl<'a, 'tcx> Visitor<'tcx> for CallsVisitor<'a, 'tcx> {
    fn visit_terminator(
        &mut self,
        _block: BasicBlock,
        terminator: &Terminator<'tcx>,
        _location: Location,
    ) {
        if let TerminatorKind::Call {
            ref func,
            args: _,
            destination: _,
            cleanup: _,
        } = terminator.kind {
            if let Operand::Constant(constant) = func {
                if let TyKind::FnDef(callee_def_id, substs) = constant.literal.ty.sty {
                      if callee_def_id.is_local() {
                          let param_env = self.cx.tcx.param_env(self.cx.tcx.hir.local_def_id(self.fn_info.decl_id()));
                          if let Some(instance) = ty::Instance::resolve(self.cx.tcx, param_env, callee_def_id, substs) {
                                match instance.def {
                                    ty::InstanceDef::Item(def_id)
                                    | ty::InstanceDef::Intrinsic(def_id)
                                    | ty::InstanceDef::Virtual(def_id, _) => {
                                        let node_id = self.cx.tcx.hir.def_index_to_node_id(def_id.index);
                                        self.fn_info.push_local_call(node_id);

                                    }
                                    _ => error!("ty::InstanceDef:: NOT handled {:?}", instance.def),
                                }
                          } else {
                              // Generics
                              let node_id = self.cx.tcx.hir.def_index_to_node_id(callee_def_id.index);
                              self.fn_info.push_local_call(node_id);
                          }
                    } else {
                        let safety =
                            match self.cx.tcx.fn_sig(callee_def_id).unsafety() {
                                hir::Unsafety::Unsafe => {fn_info::Safety::Unsafe}
                                hir::Unsafety::Normal => {fn_info::Safety::Normal}
                            };
                        info!("External call {:?}", func);

                        self.fn_info.push_external_call(self.cx, callee_def_id,safety);
                    }

                } else {
                    error!("TypeVariants NOT handled {:?}", constant.literal.ty.sty);
                }
            } else {
                error!("calls.rs::Operand Type NOT handled {:?} at {:?}"
                       , func, util::get_file_and_line(self.cx,terminator.source_info.span));
            }
        }
    }
}

Then, I have another visitor that looks for unsafe blocks. When it finds one, it marks the function as having unsafe. 
Next, I propagate this on the call graph.

For each external call, I lookup the results of the analysis in the output files of the external calls.

There are two problems:
- multiple paths to the same method. I only save one of them.
- the bigger problems are the generics in external calls. Currently, I ignore them, and that is a bug. 

Is there a better way of doing this? Could I access the HIR of the external call and with the bindings for generics to determine if there is any unsafe block in the call tree?
